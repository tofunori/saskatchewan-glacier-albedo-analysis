"""
Exports et rapports pour l'analyse de tendances d'alb√©do
=======================================================

Ce module g√®re tous les exports de donn√©es et la g√©n√©ration de rapports
texte et Excel pour l'analyse des tendances d'alb√©do.
"""

import os
import pandas as pd
import numpy as np
from datetime import datetime
from .config import (FRACTION_CLASSES, CLASS_LABELS, TREND_SYMBOLS,
                    get_significance_marker, EXPORT_CONFIG)
from .utils import print_section_header, format_pvalue, ensure_directory_exists, get_timestamp

class ResultsExporter:
    """
    Classe pour exporter les r√©sultats d'analyse sous diff√©rents formats
    """
    
    def __init__(self, data_loader):
        """
        Initialise l'exporteur
        
        Args:
            data_loader: Instance de SaskatchewanDataLoader avec donn√©es charg√©es
        """
        self.data_loader = data_loader
        self.data = data_loader.data
        self.fraction_classes = FRACTION_CLASSES
        self.class_labels = CLASS_LABELS
        
    def export_excel_report(self, all_results, variable='mean', output_path=None):
        """
        Exporte un rapport Excel complet avec tous les r√©sultats
        
        Args:
            all_results (dict): Tous les r√©sultats d'analyse
            variable (str): Variable analys√©e
            output_path (str, optional): Chemin de sortie
            
        Returns:
            str: Chemin du fichier Excel cr√©√©
        """
        print_section_header("Export du rapport Excel", level=2)
        
        if output_path is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_path = f'saskatchewan_albedo_analysis_{variable}_{timestamp}.xlsx'
        
        ensure_directory_exists(output_path)
        
        try:
            with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
                
                # 1. Feuille de m√©tadonn√©es
                self._export_metadata_sheet(writer, all_results, variable)
                
                # 2. Feuille de r√©sum√© des tendances de base
                if 'basic_trends' in all_results:
                    self._export_basic_trends_sheet(writer, all_results['basic_trends'], variable)
                
                # 3. Feuille des analyses mensuelles
                if 'monthly_trends' in all_results:
                    self._export_monthly_trends_sheet(writer, all_results['monthly_trends'], variable)
                
                # 4. Feuille d'autocorr√©lation
                if 'autocorr_results' in all_results:
                    self._export_autocorr_sheet(writer, all_results['autocorr_results'], variable)
                
                # 5. Feuille de bootstrap
                if 'bootstrap_results' in all_results:
                    self._export_bootstrap_sheet(writer, all_results['bootstrap_results'], variable)
                
                # 6. Feuille de donn√©es spatiales
                if 'spatial_results' in all_results:
                    self._export_spatial_sheet(writer, all_results['spatial_results'], variable)
                
                # 7. Feuille de donn√©es brutes (limit√©e)
                self._export_raw_data_sheet(writer, variable)
            
            print(f\"‚úÖ Rapport Excel export√©: {output_path}\")\n            \n            # V√©rifier la taille du fichier\n            file_size_mb = os.path.getsize(output_path) / (1024 * 1024)\n            print(f\"üìä Taille du fichier: {file_size_mb:.2f} MB\")\n            \n            return output_path\n            \n        except Exception as e:\n            print(f\"‚ùå Erreur lors de l'export Excel: {e}\")\n            return None\n    \n    def export_text_report(self, all_results, variable='mean', output_path=None):\n        \"\"\"\n        Exporte un rapport texte complet de toutes les analyses statistiques\n        \n        Args:\n            all_results (dict): Tous les r√©sultats d'analyse\n            variable (str): Variable analys√©e\n            output_path (str, optional): Chemin de sortie\n            \n        Returns:\n            str: Chemin du fichier texte cr√©√©\n        \"\"\"\n        print_section_header(\"Export du rapport texte complet\", level=2)\n        \n        if output_path is None:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            output_path = f'saskatchewan_albedo_statistical_report_{variable}_{timestamp}.txt'\n        \n        ensure_directory_exists(output_path)\n        \n        try:\n            with open(output_path, 'w', encoding='utf-8') as f:\n                \n                # En-t√™te du rapport\n                self._write_report_header(f, variable)\n                \n                # M√©tadonn√©es\n                self._write_metadata_section(f, all_results)\n                \n                # R√©sultats des tendances de base\n                if 'basic_trends' in all_results:\n                    self._write_basic_trends_section(f, all_results['basic_trends'], variable)\n                \n                # Analyses mensuelles\n                if 'monthly_trends' in all_results:\n                    self._write_monthly_trends_section(f, all_results['monthly_trends'], variable)\n                \n                # Analyses d'autocorr√©lation\n                if 'autocorr_results' in all_results:\n                    self._write_autocorr_section(f, all_results['autocorr_results'], variable)\n                \n                # Bootstrap\n                if 'bootstrap_results' in all_results:\n                    self._write_bootstrap_section(f, all_results['bootstrap_results'], variable)\n                \n                # Analyses spatiales\n                if 'spatial_results' in all_results:\n                    self._write_spatial_section(f, all_results['spatial_results'], variable)\n                \n                # Conclusions et recommandations\n                self._write_conclusions_section(f, all_results, variable)\n                \n                # Pied de page\n                self._write_report_footer(f)\n            \n            print(f\"‚úÖ Rapport texte export√©: {output_path}\")\n            \n            # Informations sur le fichier\n            file_size_kb = os.path.getsize(output_path) / 1024\n            with open(output_path, 'r', encoding='utf-8') as f:\n                line_count = sum(1 for _ in f)\n            \n            print(f\"üìÑ Taille: {file_size_kb:.1f} KB, {line_count} lignes\")\n            \n            return output_path\n            \n        except Exception as e:\n            print(f\"‚ùå Erreur lors de l'export texte: {e}\")\n            return None\n    \n    def _export_metadata_sheet(self, writer, all_results, variable):\n        \"\"\"Exporte la feuille de m√©tadonn√©es\"\"\"\n        metadata = all_results.get('metadata', {})\n        data_summary = metadata.get('data_summary', {})\n        \n        # Informations g√©n√©rales\n        info_data = [\n            ['Param√®tre', 'Valeur'],\n            ['Date d\\'analyse', get_timestamp()],\n            ['Variable analys√©e', variable],\n            ['Fichier source', metadata.get('csv_path', 'N/A')],\n            ['Observations totales', data_summary.get('total_observations', 'N/A')],\n            ['P√©riode d√©but', str(data_summary.get('date_range', {}).get('start', 'N/A'))],\n            ['P√©riode fin', str(data_summary.get('date_range', {}).get('end', 'N/A'))],\n            ['Ann√©es couvertes', ', '.join(map(str, data_summary.get('years_covered', [])))],\n            ['Mois analys√©s', ', '.join(map(str, data_summary.get('months_covered', [])))]\n        ]\n        \n        df_info = pd.DataFrame(info_data[1:], columns=info_data[0])\n        df_info.to_excel(writer, sheet_name='M√©tadonn√©es', index=False)\n        \n        # Disponibilit√© des donn√©es par fraction\n        if 'fractions_available' in data_summary:\n            fraction_data = []\n            for frac_info in data_summary['fractions_available']:\n                fraction = frac_info['fraction']\n                label = frac_info['label']\n                mean_data = frac_info['data']['mean']\n                median_data = frac_info['data']['median']\n                \n                fraction_data.append({\n                    'Fraction': fraction,\n                    'Label': label,\n                    'Mean_available': mean_data['available'],\n                    'Mean_observations': mean_data.get('valid_observations', 0),\n                    'Mean_missing_pct': mean_data.get('missing_percentage', 0),\n                    'Median_available': median_data['available'],\n                    'Median_observations': median_data.get('valid_observations', 0),\n                    'Median_missing_pct': median_data.get('missing_percentage', 0)\n                })\n            \n            df_fractions = pd.DataFrame(fraction_data)\n            df_fractions.to_excel(writer, sheet_name='Disponibilit√©_donn√©es', index=False)\n    \n    def _export_basic_trends_sheet(self, writer, basic_results, variable):\n        \"\"\"Exporte la feuille des tendances de base\"\"\"\n        trends_data = []\n        \n        for fraction, result in basic_results.items():\n            if result.get('error', False):\n                continue\n                \n            mk = result['mann_kendall']\n            sen = result['sen_slope']\n            autocorr = result.get('autocorrelation', {})\n            \n            trends_data.append({\n                'Fraction': fraction,\n                'Label': result['label'],\n                'N_observations': result['n_obs'],\n                'N_removed': result['n_removed'],\n                'Periode_debut': result['data_range']['start'],\n                'Periode_fin': result['data_range']['end'],\n                'MK_tendance': mk['trend'],\n                'MK_p_value': mk['p_value'],\n                'MK_tau': mk['tau'],\n                'MK_s': mk['s'],\n                'MK_z': mk['z'],\n                'Sen_slope': sen['slope'],\n                'Sen_slope_decade': sen['slope_per_decade'],\n                'Sen_intercept': sen['intercept'],\n                'Sen_CI_low': sen.get('confidence_interval', {}).get('low', np.nan),\n                'Sen_CI_high': sen.get('confidence_interval', {}).get('high', np.nan),\n                'Sen_CI_low_decade': sen.get('confidence_interval', {}).get('low_per_decade', np.nan),\n                'Sen_CI_high_decade': sen.get('confidence_interval', {}).get('high_per_decade', np.nan),\n                'Autocorr_lag1': autocorr.get('lag1', np.nan),\n                'Autocorr_significant': autocorr.get('significant', False),\n                'Significativite': get_significance_marker(mk['p_value'])\n            })\n        \n        df_trends = pd.DataFrame(trends_data)\n        df_trends.to_excel(writer, sheet_name='Tendances_base', index=False)\n    \n    def _export_monthly_trends_sheet(self, writer, monthly_results, variable):\n        \"\"\"Exporte la feuille des tendances mensuelles\"\"\"\n        monthly_data = []\n        \n        for month, month_result in monthly_results.items():\n            month_name = month_result['month_name']\n            \n            for fraction, fraction_result in month_result['fractions'].items():\n                mk = fraction_result['mann_kendall']\n                sen = fraction_result['sen_slope']\n                \n                monthly_data.append({\n                    'Mois': month,\n                    'Mois_nom': month_name,\n                    'Fraction': fraction,\n                    'Label': fraction_result['label'],\n                    'N_observations': fraction_result['n_obs'],\n                    'MK_tendance': mk['trend'],\n                    'MK_p_value': mk['p_value'],\n                    'MK_tau': mk['tau'],\n                    'Sen_slope_decade': sen['slope_per_decade'],\n                    'Significativite': get_significance_marker(mk['p_value'])\n                })\n        \n        df_monthly = pd.DataFrame(monthly_data)\n        df_monthly.to_excel(writer, sheet_name='Tendances_mensuelles', index=False)\n    \n    def _export_autocorr_sheet(self, writer, autocorr_results, variable):\n        \"\"\"Exporte la feuille d'autocorr√©lation\"\"\"\n        autocorr_data = []\n        \n        for fraction, result in autocorr_results.items():\n            if result.get('error', False):\n                continue\n                \n            autocorr = result['autocorrelation']\n            recommendation = result['recommendation']\n            \n            autocorr_data.append({\n                'Fraction': fraction,\n                'Label': result['label'],\n                'N_observations': result['n_obs'],\n                'Autocorr_lag1': autocorr['lag1'],\n                'Autocorr_lag2': autocorr.get('lag2', np.nan),\n                'Autocorr_lag3': autocorr.get('lag3', np.nan),\n                'Autocorr_status': autocorr['status'],\n                'Autocorr_significant': autocorr['significant'],\n                'Test_recommande': recommendation['recommended_test'],\n                'Confiance_recommandation': recommendation['confidence'],\n                'Raison_recommandation': recommendation['reason']\n            })\n            \n            # Ajouter les r√©sultats des diff√©rents tests\n            if 'mann_kendall_original' in result:\n                orig = result['mann_kendall_original']\n                autocorr_data[-1].update({\n                    'MK_original_tendance': orig['trend'],\n                    'MK_original_p_value': orig['p_value'],\n                    'MK_original_tau': orig['tau']\n                })\n            \n            if result.get('mann_kendall_modified'):\n                mod = result['mann_kendall_modified']\n                autocorr_data[-1].update({\n                    'MK_modifie_tendance': mod['trend'],\n                    'MK_modifie_p_value': mod['p_value'],\n                    'MK_modifie_tau': mod['tau']\n                })\n            \n            if result.get('mann_kendall_prewhitened'):\n                pre = result['mann_kendall_prewhitened']\n                autocorr_data[-1].update({\n                    'MK_preblanchi_tendance': pre['trend'],\n                    'MK_preblanchi_p_value': pre['p_value'],\n                    'MK_preblanchi_tau': pre['tau']\n                })\n        \n        df_autocorr = pd.DataFrame(autocorr_data)\n        df_autocorr.to_excel(writer, sheet_name='Autocorr√©lation', index=False)\n    \n    def _export_bootstrap_sheet(self, writer, bootstrap_results, variable):\n        \"\"\"Exporte la feuille de bootstrap\"\"\"\n        bootstrap_data = []\n        \n        for fraction, result in bootstrap_results.items():\n            if result.get('error', False):\n                continue\n                \n            slope_boot = result['slope_bootstrap']\n            pval_boot = result['pvalue_bootstrap']\n            \n            bootstrap_data.append({\n                'Fraction': fraction,\n                'Label': result['label'],\n                'N_observations': result['n_obs'],\n                'N_bootstrap': result['n_bootstrap'],\n                'N_successful': result['n_successful'],\n                'Slope_median': slope_boot['median'],\n                'Slope_CI_95_low': slope_boot['ci_95_low'],\n                'Slope_CI_95_high': slope_boot['ci_95_high'],\n                'Slope_std': slope_boot['std'],\n                'Pvalue_mean': pval_boot['mean'],\n                'Pvalue_CI_95_low': pval_boot['ci_95_low'],\n                'Pvalue_CI_95_high': pval_boot['ci_95_high'],\n                'Significant_proportion': pval_boot['significant_proportion']\n            })\n        \n        df_bootstrap = pd.DataFrame(bootstrap_data)\n        df_bootstrap.to_excel(writer, sheet_name='Bootstrap', index=False)\n    \n    def _export_spatial_sheet(self, writer, spatial_results, variable):\n        \"\"\"Exporte la feuille des analyses spatiales\"\"\"\n        if 'spatial_data' in spatial_results:\n            spatial_df = spatial_results['spatial_data']\n            spatial_df.to_excel(writer, sheet_name='Analyse_spatiale', index=False)\n    \n    def _export_raw_data_sheet(self, writer, variable):\n        \"\"\"Exporte un √©chantillon des donn√©es brutes\"\"\"\n        # Limiter les donn√©es pour √©viter des fichiers trop gros\n        max_rows = EXPORT_CONFIG['excel_max_rows']\n        \n        # S√©lectionner les colonnes pertinentes\n        relevant_cols = ['date', 'year', 'month', 'doy', 'decimal_year']\n        \n        # Ajouter les colonnes d'alb√©do\n        for fraction in self.fraction_classes:\n            for var in ['mean', 'median']:\n                col = f'{fraction}_{var}'\n                if col in self.data.columns:\n                    relevant_cols.append(col)\n        \n        # √âchantillonner les donn√©es si n√©cessaire\n        if len(self.data) > max_rows:\n            sampled_data = self.data[relevant_cols].sample(n=max_rows, random_state=42)\n            sampled_data = sampled_data.sort_values('date')\n        else:\n            sampled_data = self.data[relevant_cols]\n        \n        sampled_data.to_excel(writer, sheet_name='Donn√©es_√©chantillon', index=False)\n    \n    def _write_report_header(self, f, variable):\n        \"\"\"√âcrit l'en-t√™te du rapport texte\"\"\"\n        f.write(\"=\"*80 + \"\\n\")\n        f.write(\"RAPPORT STATISTIQUE COMPLET\\n\")\n        f.write(\"ANALYSE DES TENDANCES D'ALB√âDO DU GLACIER SASKATCHEWAN\\n\")\n        f.write(\"=\"*80 + \"\\n\\n\")\n        f.write(f\"Variable analys√©e: {variable.title()}\\n\")\n        f.write(f\"Date du rapport: {get_timestamp()}\\n\")\n        f.write(f\"G√©n√©r√© par: Saskatchewan Albedo Trend Analysis Package v2.0\\n\\n\")\n    \n    def _write_metadata_section(self, f, all_results):\n        \"\"\"√âcrit la section des m√©tadonn√©es\"\"\"\n        f.write(\"1. M√âTADONN√âES DE L'ANALYSE\\n\")\n        f.write(\"-\"*40 + \"\\n\")\n        \n        metadata = all_results.get('metadata', {})\n        data_summary = metadata.get('data_summary', {})\n        \n        f.write(f\"Fichier source: {metadata.get('csv_path', 'N/A')}\\n\")\n        f.write(f\"Observations totales: {data_summary.get('total_observations', 'N/A')}\\n\")\n        \n        date_range = data_summary.get('date_range', {})\n        if date_range:\n            f.write(f\"P√©riode d'analyse: {date_range.get('start', 'N/A')} √† {date_range.get('end', 'N/A')}\\n\")\n        \n        years = data_summary.get('years_covered', [])\n        if years:\n            f.write(f\"Ann√©es couvertes: {len(years)} ann√©es ({min(years)}-{max(years)})\\n\")\n        \n        months = data_summary.get('months_covered', [])\n        if months:\n            f.write(f\"Mois analys√©s: {', '.join(map(str, months))}\\n\")\n        \n        f.write(\"\\n\")\n    \n    def _write_basic_trends_section(self, f, basic_results, variable):\n        \"\"\"√âcrit la section des tendances de base\"\"\"\n        f.write(\"2. ANALYSES DE TENDANCES DE BASE (MANN-KENDALL & SEN'S SLOPE)\\n\")\n        f.write(\"-\"*60 + \"\\n\\n\")\n        \n        # R√©sum√© g√©n√©ral\n        total_fractions = len([r for r in basic_results.values() if not r.get('error', False)])\n        significant_count = 0\n        increasing_count = 0\n        decreasing_count = 0\n        \n        for result in basic_results.values():\n            if result.get('error', False):\n                continue\n            mk = result['mann_kendall']\n            if mk['p_value'] < 0.05:\n                significant_count += 1\n            if mk['trend'] == 'increasing':\n                increasing_count += 1\n            elif mk['trend'] == 'decreasing':\n                decreasing_count += 1\n        \n        f.write(f\"R√âSUM√â G√âN√âRAL:\\n\")\n        f.write(f\"‚Ä¢ Fractions analys√©es: {total_fractions}\\n\")\n        f.write(f\"‚Ä¢ Tendances significatives (p < 0.05): {significant_count} ({significant_count/total_fractions*100:.1f}%)\\n\")\n        f.write(f\"‚Ä¢ Tendances croissantes: {increasing_count}\\n\")\n        f.write(f\"‚Ä¢ Tendances d√©croissantes: {decreasing_count}\\n\\n\")\n        \n        # D√©tails par fraction\n        f.write(\"R√âSULTATS D√âTAILL√âS PAR FRACTION:\\n\\n\")\n        \n        for fraction, result in basic_results.items():\n            if result.get('error', False):\n                f.write(f\"{result['label']}: ERREUR - Donn√©es insuffisantes\\n\\n\")\n                continue\n            \n            mk = result['mann_kendall']\n            sen = result['sen_slope']\n            autocorr = result.get('autocorrelation', {})\n            \n            f.write(f\"{result['label']} ({fraction}):\\n\")\n            f.write(f\"  ‚Ä¢ Observations: {result['n_obs']} (supprim√©es: {result['n_removed']})\\n\")\n            f.write(f\"  ‚Ä¢ P√©riode: {result['data_range']['start'].strftime('%Y-%m-%d')} √† {result['data_range']['end'].strftime('%Y-%m-%d')}\\n\")\n            f.write(f\"  ‚Ä¢ Mann-Kendall:\\n\")\n            f.write(f\"    - Tendance: {mk['trend']} {get_significance_marker(mk['p_value'])}\\n\")\n            f.write(f\"    - P-value: {format_pvalue(mk['p_value'])}\\n\")\n            f.write(f\"    - Tau de Kendall: {mk['tau']:.4f}\\n\")\n            f.write(f\"    - Statistique S: {mk['s']}\\n\")\n            f.write(f\"    - Z-score: {mk['z']:.4f}\\n\")\n            f.write(f\"  ‚Ä¢ Pente de Sen:\\n\")\n            f.write(f\"    - Pente: {sen['slope']:.8f} par ann√©e\\n\")\n            f.write(f\"    - Pente: {sen['slope_per_decade']:.6f} par d√©cennie\\n\")\n            f.write(f\"    - Intercept: {sen['intercept']:.6f}\\n\")\n            \n            if 'confidence_interval' in sen:\n                ci = sen['confidence_interval']\n                f.write(f\"    - IC 95%: [{ci['low_per_decade']:.6f}, {ci['high_per_decade']:.6f}] par d√©cennie\\n\")\n            \n            f.write(f\"  ‚Ä¢ Autocorr√©lation lag-1: {autocorr.get('lag1', 'N/A'):.3f}\")\n            if autocorr.get('significant', False):\n                f.write(\" (significative)\")\n            f.write(\"\\n\\n\")\n    \n    def _write_monthly_trends_section(self, f, monthly_results, variable):\n        \"\"\"√âcrit la section des tendances mensuelles\"\"\"\n        f.write(\"3. ANALYSES SAISONNI√àRES ET MENSUELLES\\n\")\n        f.write(\"-\"*45 + \"\\n\\n\")\n        \n        for month, month_result in monthly_results.items():\n            month_name = month_result['month_name']\n            f.write(f\"MOIS: {month_name.upper()} ({month})\\n\")\n            f.write(\"-\" * 30 + \"\\n\")\n            \n            significant_this_month = 0\n            \n            for fraction, fraction_result in month_result['fractions'].items():\n                mk = fraction_result['mann_kendall']\n                sen = fraction_result['sen_slope']\n                \n                if mk['p_value'] < 0.05:\n                    significant_this_month += 1\n                \n                trend_symbol = TREND_SYMBOLS.get(mk['trend'], '‚ùì')\n                significance = get_significance_marker(mk['p_value'])\n                \n                f.write(f\"  {fraction_result['label']}:\\n\")\n                f.write(f\"    ‚Ä¢ Observations: {fraction_result['n_obs']}\\n\")\n                f.write(f\"    ‚Ä¢ Tendance: {trend_symbol} {mk['trend']} {significance}\\n\")\n                f.write(f\"    ‚Ä¢ P-value: {format_pvalue(mk['p_value'])}\\n\")\n                f.write(f\"    ‚Ä¢ Pente Sen: {sen['slope_per_decade']:.6f} par d√©cennie\\n\")\n                f.write(f\"    ‚Ä¢ Tau: {mk['tau']:.4f}\\n\\n\")\n            \n            f.write(f\"  R√©sum√© {month_name}: {significant_this_month} tendance(s) significative(s)\\n\\n\")\n    \n    def _write_autocorr_section(self, f, autocorr_results, variable):\n        \"\"\"√âcrit la section d'autocorr√©lation\"\"\"\n        f.write(\"4. CONTR√îLE D'AUTOCORR√âLATION\\n\")\n        f.write(\"-\"*35 + \"\\n\\n\")\n        \n        f.write(\"ANALYSE DE L'AUTOCORR√âLATION LAG-1:\\n\\n\")\n        \n        for fraction, result in autocorr_results.items():\n            if result.get('error', False):\n                continue\n                \n            autocorr = result['autocorrelation']\n            recommendation = result['recommendation']\n            \n            f.write(f\"{result['label']}:\\n\")\n            f.write(f\"  ‚Ä¢ Autocorr√©lation lag-1: {autocorr['lag1']:.3f}\\n\")\n            f.write(f\"  ‚Ä¢ Statut: {autocorr['status']}\\n\")\n            f.write(f\"  ‚Ä¢ Test recommand√©: {recommendation['recommended_test']}\\n\")\n            f.write(f\"  ‚Ä¢ Confiance: {recommendation['confidence']}\\n\")\n            f.write(f\"  ‚Ä¢ Raison: {recommendation['reason']}\\n\")\n            \n            # R√©sultats des diff√©rents tests\n            if 'mann_kendall_original' in result:\n                orig = result['mann_kendall_original']\n                f.write(f\"  ‚Ä¢ Test original: {orig['trend']} (p={format_pvalue(orig['p_value'])})\\n\")\n            \n            if result.get('mann_kendall_modified'):\n                mod = result['mann_kendall_modified']\n                f.write(f\"  ‚Ä¢ Test modifi√©: {mod['trend']} (p={format_pvalue(mod['p_value'])})\\n\")\n            \n            if result.get('mann_kendall_prewhitened'):\n                pre = result['mann_kendall_prewhitened']\n                f.write(f\"  ‚Ä¢ Test pr√©-blanchi: {pre['trend']} (p={format_pvalue(pre['p_value'])})\\n\")\n            \n            f.write(\"\\n\")\n    \n    def _write_bootstrap_section(self, f, bootstrap_results, variable):\n        \"\"\"√âcrit la section de bootstrap\"\"\"\n        f.write(\"5. INTERVALLES DE CONFIANCE BOOTSTRAP\\n\")\n        f.write(\"-\"*45 + \"\\n\\n\")\n        \n        for fraction, result in bootstrap_results.items():\n            if result.get('error', False):\n                continue\n                \n            slope_boot = result['slope_bootstrap']\n            pval_boot = result['pvalue_bootstrap']\n            \n            f.write(f\"{result['label']}:\\n\")\n            f.write(f\"  ‚Ä¢ It√©rations bootstrap: {result['n_bootstrap']} (r√©ussies: {result['n_successful']})\\n\")\n            f.write(f\"  ‚Ä¢ Pente m√©diane: {slope_boot['median']:.6f} par d√©cennie\\n\")\n            f.write(f\"  ‚Ä¢ IC 95%: [{slope_boot['ci_95_low']:.6f}, {slope_boot['ci_95_high']:.6f}]\\n\")\n            f.write(f\"  ‚Ä¢ √âcart-type bootstrap: {slope_boot['std']:.6f}\\n\")\n            f.write(f\"  ‚Ä¢ P-value moyenne: {format_pvalue(pval_boot['mean'])}\\n\")\n            f.write(f\"  ‚Ä¢ Proportion de tests significatifs: {pval_boot['significant_proportion']:.1%}\\n\\n\")\n    \n    def _write_spatial_section(self, f, spatial_results, variable):\n        \"\"\"√âcrit la section spatiale\"\"\"\n        f.write(\"6. ANALYSE SPATIALE\\n\")\n        f.write(\"-\"*25 + \"\\n\\n\")\n        \n        if 'summary' in spatial_results:\n            summary = spatial_results['summary']\n            slope_range = summary['slope_range']\n            \n            f.write(f\"R√âSUM√â SPATIAL:\\n\")\n            f.write(f\"‚Ä¢ Fractions analys√©es: {summary['n_fractions']}\\n\")\n            f.write(f\"‚Ä¢ Tendances significatives: {summary['n_significant']}\\n\")\n            f.write(f\"‚Ä¢ Pente minimale: {slope_range['min']:.6f} par d√©cennie\\n\")\n            f.write(f\"‚Ä¢ Pente maximale: {slope_range['max']:.6f} par d√©cennie\\n\")\n            f.write(f\"‚Ä¢ Pente moyenne: {slope_range['mean']:.6f} par d√©cennie\\n\")\n            f.write(f\"‚Ä¢ √âcart-type: {slope_range['std']:.6f} par d√©cennie\\n\\n\")\n        \n        if 'spatial_data' in spatial_results:\n            spatial_df = spatial_results['spatial_data']\n            \n            f.write(\"DISTRIBUTION SPATIALE DES PENTES:\\n\")\n            for _, row in spatial_df.sort_values('slope_decade', ascending=False).iterrows():\n                trend_symbol = TREND_SYMBOLS.get(row['trend'], '‚ùì')\n                f.write(f\"  {trend_symbol} {row['label']}: {row['slope_decade']:.6f}/d√©cennie {row['significance']}\\n\")\n    \n    def _write_conclusions_section(self, f, all_results, variable):\n        \"\"\"√âcrit la section des conclusions\"\"\"\n        f.write(\"\\n7. CONCLUSIONS ET RECOMMANDATIONS\\n\")\n        f.write(\"-\"*40 + \"\\n\\n\")\n        \n        # Analyser les r√©sultats pour g√©n√©rer des conclusions\n        basic_results = all_results.get('basic_trends', {})\n        \n        significant_trends = []\n        decreasing_trends = []\n        autocorr_issues = []\n        \n        for fraction, result in basic_results.items():\n            if result.get('error', False):\n                continue\n                \n            mk = result['mann_kendall']\n            if mk['p_value'] < 0.05:\n                significant_trends.append(result['label'])\n                if mk['trend'] == 'decreasing':\n                    decreasing_trends.append(result['label'])\n            \n            autocorr = result.get('autocorrelation', {})\n            if autocorr.get('significant', False):\n                autocorr_issues.append(result['label'])\n        \n        f.write(\"PRINCIPALES CONCLUSIONS:\\n\\n\")\n        \n        if significant_trends:\n            f.write(f\"1. TENDANCES SIGNIFICATIVES D√âTECT√âES:\\n\")\n            f.write(f\"   {len(significant_trends)} fraction(s) pr√©sentent des tendances statistiquement significatives:\\n\")\n            for trend in significant_trends:\n                f.write(f\"   ‚Ä¢ {trend}\\n\")\n            f.write(\"\\n\")\n        else:\n            f.write(\"1. AUCUNE TENDANCE SIGNIFICATIVE:\\n\")\n            f.write(\"   Aucune fraction ne pr√©sente de tendance statistiquement significative\\n\")\n            f.write(\"   au seuil Œ± = 0.05.\\n\\n\")\n        \n        if decreasing_trends:\n            f.write(f\"2. TENDANCES √Ä LA BAISSE:\\n\")\n            f.write(f\"   {len(decreasing_trends)} fraction(s) montrent une diminution significative de l'alb√©do:\\n\")\n            for trend in decreasing_trends:\n                f.write(f\"   ‚Ä¢ {trend}\\n\")\n            f.write(\"   Cela pourrait indiquer une fonte accrue ou des changements de surface.\\n\\n\")\n        \n        if autocorr_issues:\n            f.write(f\"3. PROBL√àMES D'AUTOCORR√âLATION:\\n\")\n            f.write(f\"   {len(autocorr_issues)} fraction(s) pr√©sentent une autocorr√©lation significative:\\n\")\n            for issue in autocorr_issues:\n                f.write(f\"   ‚Ä¢ {issue}\\n\")\n            f.write(\"   Les tests modifi√©s ou pr√©-blanchis sont recommand√©s pour ces fractions.\\n\\n\")\n        \n        f.write(\"RECOMMANDATIONS M√âTHODOLOGIQUES:\\n\\n\")\n        f.write(\"‚Ä¢ Utiliser les tests Mann-Kendall modifi√©s pour les s√©ries avec autocorr√©lation\\n\")\n        f.write(\"‚Ä¢ Consid√©rer les intervalles de confiance bootstrap pour une estimation robuste\\n\")\n        f.write(\"‚Ä¢ Analyser les patterns saisonniers pour comprendre les variations temporelles\\n\")\n        f.write(\"‚Ä¢ Examiner la coh√©rence spatiale des tendances entre fractions adjacentes\\n\\n\")\n    \n    def _write_report_footer(self, f):\n        \"\"\"√âcrit le pied de page du rapport\"\"\"\n        f.write(\"\\n\" + \"=\"*80 + \"\\n\")\n        f.write(\"FIN DU RAPPORT\\n\")\n        f.write(f\"G√©n√©r√© le: {get_timestamp()}\\n\")\n        f.write(\"Saskatchewan Albedo Trend Analysis Package v2.0\\n\")\n        f.write(\"D√©velopp√© avec Claude Code Analysis\\n\")\n        f.write(\"=\"*80 + \"\\n\")\n    \n    def export_summary_csv(self, basic_results, variable='mean', output_path=None):\n        \"\"\"\n        Exporte un CSV de r√©sum√© simple pour utilisation externe\n        \n        Args:\n            basic_results (dict): R√©sultats des analyses de base\n            variable (str): Variable analys√©e\n            output_path (str, optional): Chemin de sortie\n            \n        Returns:\n            str: Chemin du fichier CSV cr√©√©\n        \"\"\"\n        if output_path is None:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            output_path = f'saskatchewan_summary_{variable}_{timestamp}.csv'\n        \n        summary_data = []\n        \n        for fraction, result in basic_results.items():\n            if result.get('error', False):\n                continue\n                \n            mk = result['mann_kendall']\n            sen = result['sen_slope']\n            \n            summary_data.append({\n                'Fraction': fraction,\n                'Label': result['label'],\n                'N_observations': result['n_obs'],\n                'Trend': mk['trend'],\n                'P_value': mk['p_value'],\n                'Significant': mk['p_value'] < 0.05,\n                'Sen_slope_per_decade': sen['slope_per_decade'],\n                'Tau': mk['tau']\n            })\n        \n        df_summary = pd.DataFrame(summary_data)\n        df_summary.to_csv(output_path, index=False)\n        \n        print(f\"‚úÖ R√©sum√© CSV export√©: {output_path}\")\n        return output_path