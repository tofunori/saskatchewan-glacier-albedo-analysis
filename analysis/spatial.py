"""
Analyses spatiales des tendances d'albédo
=========================================

Ce module contient les analyses spatiales incluant la cartographie
des pentes de Sen et les analyses de distribution spatiale.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import TwoSlopeNorm

# Import from package
from config import (FRACTION_CLASSES, CLASS_LABELS, FRACTION_COLORS, 
                      get_significance_marker, TREND_SYMBOLS)
from utils.helpers import print_section_header, format_pvalue

class SpatialAnalyzer:
    """
    Analyseur pour les tendances spatiales et cartographie
    """
    
    def __init__(self, data_loader):
        """
        Initialise l'analyseur spatial
        
        Args:
            data_loader: Instance de SaskatchewanDataLoader avec données chargées
        """
        self.data_loader = data_loader
        self.data = data_loader.data
        self.fraction_classes = FRACTION_CLASSES
        self.class_labels = CLASS_LABELS
        self.results = {}
        
    def create_sen_slope_map(self, trend_results, variable='mean', save_path=None):
        """
        Crée une cartographie des pentes de Sen par fraction
        
        Args:
            trend_results (dict): Résultats des analyses de tendances
            variable (str): Variable analysée
            save_path (str, optional): Chemin pour sauvegarder
            
        Returns:
            str: Chemin du fichier sauvegardé
        """
        print_section_header("Cartographie des pentes de Sen", level=2)
        
        # Préparer les données pour la cartographie
        spatial_data = []
        
        for fraction, result in trend_results.items():
            if result.get('error', False):
                continue
                
            mk = result['mann_kendall']
            sen = result['sen_slope']
            
            # Simuler des coordonnées spatiales basées sur les fractions
            # (En réalité, ces coordonnées viendraient des données GEE)
            fraction_positions = {
                'border': (0, 0),       # Bordure - position 0,0
                'mixed_low': (1, 0),    # Mixte bas - position 1,0
                'mixed_high': (2, 0),   # Mixte haut - position 2,0  
                'mostly_ice': (3, 0),   # Majoritaire - position 3,0
                'pure_ice': (4, 0)      # Pur - position 4,0
            }\n            \n            x, y = fraction_positions.get(fraction, (0, 0))\n            \n            spatial_data.append({\n                'fraction': fraction,\n                'label': result['label'],\n                'x': x,\n                'y': y,\n                'slope_decade': sen['slope_per_decade'],\n                'p_value': mk['p_value'],\n                'trend': mk['trend'],\n                'significance': get_significance_marker(mk['p_value']),\n                'n_obs': result['n_obs'],\n                'significant': mk['p_value'] < 0.05\n            })\n        \n        if not spatial_data:\n            print(\"❌ Pas de données pour la cartographie\")\n            return None\n        \n        spatial_df = pd.DataFrame(spatial_data)\n        \n        # Créer la figure avec plusieurs représentations\n        fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n        fig.suptitle(f'Cartographie Spatiale des Pentes de Sen - {variable.title()}', \n                     fontsize=16, fontweight='bold')\n        \n        # 1. Carte des pentes avec couleurs divergentes\n        ax1 = axes[0, 0]\n        \n        # Normalisation centrée sur zéro\n        max_abs_slope = spatial_df['slope_decade'].abs().max()\n        norm = TwoSlopeNorm(vmin=-max_abs_slope, vcenter=0, vmax=max_abs_slope)\n        \n        scatter = ax1.scatter(spatial_df['x'], spatial_df['y'], \n                             c=spatial_df['slope_decade'], cmap='RdBu_r',\n                             s=200, norm=norm, edgecolors='black', linewidth=1)\n        \n        # Ajouter les labels des fractions\n        for _, row in spatial_df.iterrows():\n            ax1.annotate(row['label'][:8], (row['x'], row['y']), \n                        xytext=(0, -25), textcoords='offset points',\n                        ha='center', fontsize=8, fontweight='bold')\n        \n        ax1.set_title('Pentes de Sen par Fraction')\n        ax1.set_xlabel('Position X (Fraction)')\n        ax1.set_ylabel('Position Y')\n        plt.colorbar(scatter, ax=ax1, label='Pente (par décennie)')\n        ax1.grid(True, alpha=0.3)\n        \n        # 2. Carte de significativité\n        ax2 = axes[0, 1]\n        \n        # Couleurs selon la significativité\n        colors = ['red' if sig else 'lightgray' for sig in spatial_df['significant']]\n        sizes = [300 if sig else 100 for sig in spatial_df['significant']]\n        \n        ax2.scatter(spatial_df['x'], spatial_df['y'], c=colors, s=sizes,\n                   edgecolors='black', linewidth=1, alpha=0.7)\n        \n        # Ajouter les marqueurs de significativité\n        for _, row in spatial_df.iterrows():\n            ax2.annotate(row['significance'], (row['x'], row['y']),\n                        ha='center', va='center', fontweight='bold',\n                        color='white' if row['significant'] else 'black')\n            \n            ax2.annotate(row['label'][:8], (row['x'], row['y']), \n                        xytext=(0, -25), textcoords='offset points',\n                        ha='center', fontsize=8)\n        \n        ax2.set_title('Significativité Statistique')\n        ax2.set_xlabel('Position X (Fraction)')\n        ax2.set_ylabel('Position Y')\n        ax2.grid(True, alpha=0.3)\n        \n        # Légende\n        from matplotlib.patches import Patch\n        legend_elements = [Patch(facecolor='red', label='Significatif (p < 0.05)'),\n                          Patch(facecolor='lightgray', label='Non significatif')]\n        ax2.legend(handles=legend_elements, loc='upper right')\n        \n        # 3. Graphique en barres des pentes\n        ax3 = axes[1, 0]\n        \n        # Trier par pente\n        sorted_data = spatial_df.sort_values('slope_decade')\n        \n        bars = ax3.barh(range(len(sorted_data)), sorted_data['slope_decade'],\n                       color=[FRACTION_COLORS.get(f, 'gray') for f in sorted_data['fraction']],\n                       alpha=0.7)\n        \n        # Ajouter une ligne à zéro\n        ax3.axvline(x=0, color='black', linestyle='--', alpha=0.5)\n        \n        # Labels\n        ax3.set_yticks(range(len(sorted_data)))\n        ax3.set_yticklabels([label[:15] for label in sorted_data['label']])\n        ax3.set_xlabel('Pente de Sen (par décennie)')\n        ax3.set_title('Pentes Triées par Magnitude')\n        ax3.grid(True, alpha=0.3, axis='x')\n        \n        # Ajouter les valeurs de significativité\n        for i, (_, row) in enumerate(sorted_data.iterrows()):\n            significance = row['significance']\n            x_pos = row['slope_decade']\n            x_text = x_pos + (0.01 if x_pos >= 0 else -0.01)\n            ax3.text(x_text, i, significance, va='center', \n                    ha='left' if x_pos >= 0 else 'right', fontweight='bold')\n        \n        # 4. Heatmap de corrélation spatiale (simulée)\n        ax4 = axes[1, 1]\n        \n        # Créer une matrice de \"distance\" entre fractions\n        n_fractions = len(spatial_df)\n        correlation_matrix = np.zeros((n_fractions, n_fractions))\n        \n        for i in range(n_fractions):\n            for j in range(n_fractions):\n                if i == j:\n                    correlation_matrix[i, j] = 1.0\n                else:\n                    # Corrélation simulée basée sur la distance des pentes\n                    slope_i = spatial_df.iloc[i]['slope_decade']\n                    slope_j = spatial_df.iloc[j]['slope_decade']\n                    correlation_matrix[i, j] = np.exp(-abs(slope_i - slope_j) * 10)\n        \n        im = ax4.imshow(correlation_matrix, cmap='coolwarm', vmin=0, vmax=1)\n        \n        # Labels\n        labels = [label[:8] for label in spatial_df['label']]\n        ax4.set_xticks(range(n_fractions))\n        ax4.set_yticks(range(n_fractions))\n        ax4.set_xticklabels(labels, rotation=45, ha='right')\n        ax4.set_yticklabels(labels)\n        \n        # Ajouter les valeurs dans les cellules\n        for i in range(n_fractions):\n            for j in range(n_fractions):\n                ax4.text(j, i, f'{correlation_matrix[i, j]:.2f}',\n                        ha='center', va='center', fontweight='bold',\n                        color='white' if correlation_matrix[i, j] > 0.5 else 'black')\n        \n        ax4.set_title('Matrice de Similitude des Pentes')\n        plt.colorbar(im, ax=ax4, label='Similitude')\n        \n        plt.tight_layout()\n        \n        # Sauvegarder\n        if save_path is None:\n            save_path = f'spatial_slope_analysis_{variable}.png'\n        \n        plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        print(f\"✓ Cartographie sauvegardée: {save_path}\")\n        \n        plt.show()\n        \n        # Stocker les résultats\n        self.results[f'spatial_{variable}'] = {\n            'spatial_data': spatial_df,\n            'correlation_matrix': correlation_matrix,\n            'summary': {\n                'n_fractions': len(spatial_df),\n                'n_significant': spatial_df['significant'].sum(),\n                'slope_range': {\n                    'min': spatial_df['slope_decade'].min(),\n                    'max': spatial_df['slope_decade'].max(),\n                    'mean': spatial_df['slope_decade'].mean(),\n                    'std': spatial_df['slope_decade'].std()\n                }\n            }\n        }\n        \n        return save_path\n    \n    def create_spatial_distribution_analysis(self, trend_results, variable='mean', save_path=None):\n        \"\"\"\n        Analyse la distribution spatiale des tendances\n        \n        Args:\n            trend_results (dict): Résultats des analyses de tendances\n            variable (str): Variable analysée\n            save_path (str, optional): Chemin pour sauvegarder\n            \n        Returns:\n            str: Chemin du fichier sauvegardé\n        \"\"\"\n        print_section_header(\"Analyse de distribution spatiale\", level=3)\n        \n        if not trend_results:\n            print(\"❌ Pas de données de tendances disponibles\")\n            return None\n        \n        # Préparer les données\n        distribution_data = []\n        \n        for fraction, result in trend_results.items():\n            if result.get('error', False):\n                continue\n                \n            mk = result['mann_kendall']\n            sen = result['sen_slope']\n            \n            distribution_data.append({\n                'fraction': fraction,\n                'label': result['label'],\n                'slope_decade': sen['slope_per_decade'],\n                'p_value': mk['p_value'],\n                'trend': mk['trend'],\n                'n_obs': result['n_obs'],\n                'tau': mk['tau'],\n                'autocorr': result.get('autocorrelation', {}).get('lag1', np.nan)\n            })\n        \n        if not distribution_data:\n            print(\"❌ Pas de données pour l'analyse de distribution\")\n            return None\n        \n        distrib_df = pd.DataFrame(distribution_data)\n        \n        # Créer la figure d'analyse\n        fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n        fig.suptitle(f'Analyse de Distribution Spatiale - {variable.title()}', \n                     fontsize=16, fontweight='bold')\n        \n        axes = axes.flatten()\n        \n        # 1. Distribution des pentes\n        ax1 = axes[0]\n        ax1.hist(distrib_df['slope_decade'], bins=8, alpha=0.7, color='skyblue', edgecolor='black')\n        ax1.axvline(x=0, color='red', linestyle='--', alpha=0.7, label='Pente nulle')\n        ax1.axvline(x=distrib_df['slope_decade'].mean(), color='green', linestyle='-', \n                   alpha=0.7, label='Moyenne')\n        ax1.set_title('Distribution des Pentes de Sen')\n        ax1.set_xlabel('Pente (par décennie)')\n        ax1.set_ylabel('Fréquence')\n        ax1.legend()\n        ax1.grid(True, alpha=0.3)\n        \n        # 2. Distribution des p-values\n        ax2 = axes[1]\n        ax2.hist(distrib_df['p_value'], bins=8, alpha=0.7, color='lightcoral', edgecolor='black')\n        ax2.axvline(x=0.05, color='red', linestyle='--', alpha=0.7, label='Seuil α=0.05')\n        ax2.set_title('Distribution des P-values')\n        ax2.set_xlabel('P-value')\n        ax2.set_ylabel('Fréquence')\n        ax2.legend()\n        ax2.grid(True, alpha=0.3)\n        \n        # 3. Relation pente vs p-value\n        ax3 = axes[2]\n        colors = ['red' if p < 0.05 else 'gray' for p in distrib_df['p_value']]\n        ax3.scatter(distrib_df['slope_decade'], -np.log10(distrib_df['p_value']), \n                   c=colors, alpha=0.7, s=100, edgecolors='black')\n        ax3.axhline(y=-np.log10(0.05), color='red', linestyle='--', alpha=0.7, \n                   label='Seuil significativité')\n        ax3.axvline(x=0, color='black', linestyle='-', alpha=0.3)\n        ax3.set_title('Volcano Plot: Pente vs Significativité')\n        ax3.set_xlabel('Pente de Sen (par décennie)')\n        ax3.set_ylabel('-log10(p-value)')\n        ax3.legend()\n        ax3.grid(True, alpha=0.3)\n        \n        # 4. Nombre d'observations par fraction\n        ax4 = axes[3]\n        bars = ax4.bar(range(len(distrib_df)), distrib_df['n_obs'],\n                      color=[FRACTION_COLORS.get(f, 'gray') for f in distrib_df['fraction']],\n                      alpha=0.7, edgecolor='black')\n        ax4.set_title('Nombre d\\'Observations par Fraction')\n        ax4.set_xlabel('Fraction')\n        ax4.set_ylabel('Nombre d\\'Observations')\n        ax4.set_xticks(range(len(distrib_df)))\n        ax4.set_xticklabels([label[:8] for label in distrib_df['label']], rotation=45)\n        ax4.grid(True, alpha=0.3, axis='y')\n        \n        # Ajouter les valeurs sur les barres\n        for bar, n_obs in zip(bars, distrib_df['n_obs']):\n            ax4.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 5,\n                    str(n_obs), ha='center', va='bottom', fontweight='bold')\n        \n        # 5. Boxplot des tendances par type\n        ax5 = axes[4]\n        \n        # Grouper par type de tendance\n        trend_groups = distrib_df.groupby('trend')['slope_decade'].apply(list).to_dict()\n        \n        if trend_groups:\n            trends = list(trend_groups.keys())\n            slopes = [trend_groups[trend] for trend in trends]\n            \n            bp = ax5.boxplot(slopes, labels=trends, patch_artist=True)\n            \n            # Couleurs selon le type de tendance\n            colors = ['lightgreen' if t == 'increasing' else 'lightcoral' if t == 'decreasing' else 'lightgray' \n                     for t in trends]\n            for patch, color in zip(bp['boxes'], colors):\n                patch.set_facecolor(color)\n                patch.set_alpha(0.7)\n        \n        ax5.axhline(y=0, color='black', linestyle='--', alpha=0.5)\n        ax5.set_title('Distribution des Pentes par Type de Tendance')\n        ax5.set_ylabel('Pente de Sen (par décennie)')\n        ax5.grid(True, alpha=0.3)\n        \n        # 6. Statistiques résumées\n        ax6 = axes[5]\n        ax6.axis('off')\n        \n        # Calculs de statistiques\n        n_total = len(distrib_df)\n        n_significant = (distrib_df['p_value'] < 0.05).sum()\n        n_increasing = (distrib_df['trend'] == 'increasing').sum()\n        n_decreasing = (distrib_df['trend'] == 'decreasing').sum()\n        n_no_trend = (distrib_df['trend'] == 'no trend').sum()\n        \n        mean_slope = distrib_df['slope_decade'].mean()\n        std_slope = distrib_df['slope_decade'].std()\n        median_slope = distrib_df['slope_decade'].median()\n        \n        stats_text = f\"\"\"\nSTATISTIQUES SPATIALES\n\n• Total fractions analysées: {n_total}\n• Tendances significatives: {n_significant} ({n_significant/n_total*100:.1f}%)\n\n• Type de tendances:\n  - Croissantes: {n_increasing}\n  - Décroissantes: {n_decreasing} \n  - Pas de tendance: {n_no_trend}\n\n• Pentes de Sen:\n  - Moyenne: {mean_slope:.6f}/décennie\n  - Médiane: {median_slope:.6f}/décennie\n  - Écart-type: {std_slope:.6f}/décennie\n  - Min: {distrib_df['slope_decade'].min():.6f}/décennie\n  - Max: {distrib_df['slope_decade'].max():.6f}/décennie\n        \"\"\"\n        \n        ax6.text(0.05, 0.95, stats_text, transform=ax6.transAxes, fontsize=11,\n                verticalalignment='top', fontfamily='monospace',\n                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))\n        \n        plt.tight_layout()\n        \n        # Sauvegarder\n        if save_path is None:\n            save_path = f'spatial_distribution_analysis_{variable}.png'\n        \n        plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        print(f\"✓ Analyse de distribution sauvegardée: {save_path}\")\n        \n        plt.show()\n        \n        return save_path\n    \n    def get_spatial_summary_table(self, variable='mean'):\n        \"\"\"\n        Génère un tableau de résumé de l'analyse spatiale\n        \n        Args:\n            variable (str): Variable analysée\n            \n        Returns:\n            pd.DataFrame: Tableau de résumé spatial\n        \"\"\"\n        if f'spatial_{variable}' not in self.results:\n            raise ValueError(f\"Analyse spatiale non effectuée pour {variable}\")\n        \n        spatial_data = self.results[f'spatial_{variable}']['spatial_data']\n        \n        summary_table = spatial_data[[\n            'label', 'slope_decade', 'p_value', 'trend', \n            'significance', 'n_obs', 'significant'\n        ]].copy()\n        \n        summary_table.columns = [\n            'Fraction', 'Pente_Sen_decade', 'P_value', 'Tendance',\n            'Significativité', 'N_observations', 'Significatif'\n        ]\n        \n        return summary_table.sort_values('Pente_Sen_decade', ascending=False)\n    \n    def print_spatial_summary(self, variable='mean'):\n        \"\"\"\n        Affiche un résumé de l'analyse spatiale\n        \"\"\"\n        print_section_header(\"Résumé de l'analyse spatiale\", level=2)\n        \n        if f'spatial_{variable}' not in self.results:\n            print(\"❌ Analyse spatiale non effectuée\")\n            return\n        \n        summary = self.results[f'spatial_{variable}']['summary']\n        spatial_data = self.results[f'spatial_{variable}']['spatial_data']\n        \n        print(f\"🗺️  Fractions analysées: {summary['n_fractions']}\")\n        print(f\"✅ Tendances significatives: {summary['n_significant']}\")\n        \n        slope_range = summary['slope_range']\n        print(f\"\\n📐 Pentes de Sen (par décennie):\")\n        print(f\"  • Minimum: {slope_range['min']:.6f}\")\n        print(f\"  • Maximum: {slope_range['max']:.6f}\")\n        print(f\"  • Moyenne: {slope_range['mean']:.6f}\")\n        print(f\"  • Écart-type: {slope_range['std']:.6f}\")\n        \n        # Fractions les plus extrêmes\n        max_increase = spatial_data.loc[spatial_data['slope_decade'].idxmax()]\n        max_decrease = spatial_data.loc[spatial_data['slope_decade'].idxmin()]\n        \n        print(f\"\\n🎯 Fractions extrêmes:\")\n        print(f\"  📈 Plus forte augmentation: {max_increase['label']} \")\n        print(f\"     Pente: {max_increase['slope_decade']:.6f}/décennie {max_increase['significance']}\")\n        print(f\"  📉 Plus forte diminution: {max_decrease['label']} \")\n        print(f\"     Pente: {max_decrease['slope_decade']:.6f}/décennie {max_decrease['significance']}\")\n        \n        # Significativité spatiale\n        significant_fractions = spatial_data[spatial_data['significant']]\n        if len(significant_fractions) > 0:\n            print(f\"\\n🌟 Fractions avec tendances significatives:\")\n            for _, row in significant_fractions.iterrows():\n                trend_symbol = TREND_SYMBOLS.get(row['trend'], '❓')\n                print(f\"  {trend_symbol} {row['label']}: {row['slope_decade']:.6f}/décennie {row['significance']}\")\n        else:\n            print(f\"\\n❌ Aucune fraction avec tendance significative\")"