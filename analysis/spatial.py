"""
Analyses spatiales des tendances d'alb√©do
=========================================

Ce module contient les analyses spatiales incluant la cartographie
des pentes de Sen et les analyses de distribution spatiale.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import TwoSlopeNorm

# Import from package
from config import (FRACTION_CLASSES, CLASS_LABELS, FRACTION_COLORS, 
                      get_significance_marker, TREND_SYMBOLS)
from utils.helpers import print_section_header, format_pvalue

class SpatialAnalyzer:
    """
    Analyseur pour les tendances spatiales et cartographie
    """
    
    def __init__(self, data_loader):
        """
        Initialise l'analyseur spatial
        
        Args:
            data_loader: Instance de SaskatchewanDataLoader avec donn√©es charg√©es
        """
        self.data_loader = data_loader
        self.data = data_loader.data
        self.fraction_classes = FRACTION_CLASSES
        self.class_labels = CLASS_LABELS
        self.results = {}
        
    def create_sen_slope_map(self, trend_results, variable='mean', save_path=None):
        """
        Cr√©e une cartographie des pentes de Sen par fraction
        
        Args:
            trend_results (dict): R√©sultats des analyses de tendances
            variable (str): Variable analys√©e
            save_path (str, optional): Chemin pour sauvegarder
            
        Returns:
            str: Chemin du fichier sauvegard√©
        """
        print_section_header("Cartographie des pentes de Sen", level=2)
        
        # Pr√©parer les donn√©es pour la cartographie
        spatial_data = []
        
        for fraction, result in trend_results.items():
            if result.get('error', False):
                continue
                
            mk = result['mann_kendall']
            sen = result['sen_slope']
            
            # Simuler des coordonn√©es spatiales bas√©es sur les fractions
            # (En r√©alit√©, ces coordonn√©es viendraient des donn√©es GEE)
            fraction_positions = {
                'border': (0, 0),       # Bordure - position 0,0
                'mixed_low': (1, 0),    # Mixte bas - position 1,0
                'mixed_high': (2, 0),   # Mixte haut - position 2,0  
                'mostly_ice': (3, 0),   # Majoritaire - position 3,0
                'pure_ice': (4, 0)      # Pur - position 4,0
            }\n            \n            x, y = fraction_positions.get(fraction, (0, 0))\n            \n            spatial_data.append({\n                'fraction': fraction,\n                'label': result['label'],\n                'x': x,\n                'y': y,\n                'slope_decade': sen['slope_per_decade'],\n                'p_value': mk['p_value'],\n                'trend': mk['trend'],\n                'significance': get_significance_marker(mk['p_value']),\n                'n_obs': result['n_obs'],\n                'significant': mk['p_value'] < 0.05\n            })\n        \n        if not spatial_data:\n            print(\"‚ùå Pas de donn√©es pour la cartographie\")\n            return None\n        \n        spatial_df = pd.DataFrame(spatial_data)\n        \n        # Cr√©er la figure avec plusieurs repr√©sentations\n        fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n        fig.suptitle(f'Cartographie Spatiale des Pentes de Sen - {variable.title()}', \n                     fontsize=16, fontweight='bold')\n        \n        # 1. Carte des pentes avec couleurs divergentes\n        ax1 = axes[0, 0]\n        \n        # Normalisation centr√©e sur z√©ro\n        max_abs_slope = spatial_df['slope_decade'].abs().max()\n        norm = TwoSlopeNorm(vmin=-max_abs_slope, vcenter=0, vmax=max_abs_slope)\n        \n        scatter = ax1.scatter(spatial_df['x'], spatial_df['y'], \n                             c=spatial_df['slope_decade'], cmap='RdBu_r',\n                             s=200, norm=norm, edgecolors='black', linewidth=1)\n        \n        # Ajouter les labels des fractions\n        for _, row in spatial_df.iterrows():\n            ax1.annotate(row['label'][:8], (row['x'], row['y']), \n                        xytext=(0, -25), textcoords='offset points',\n                        ha='center', fontsize=8, fontweight='bold')\n        \n        ax1.set_title('Pentes de Sen par Fraction')\n        ax1.set_xlabel('Position X (Fraction)')\n        ax1.set_ylabel('Position Y')\n        plt.colorbar(scatter, ax=ax1, label='Pente (par d√©cennie)')\n        ax1.grid(True, alpha=0.3)\n        \n        # 2. Carte de significativit√©\n        ax2 = axes[0, 1]\n        \n        # Couleurs selon la significativit√©\n        colors = ['red' if sig else 'lightgray' for sig in spatial_df['significant']]\n        sizes = [300 if sig else 100 for sig in spatial_df['significant']]\n        \n        ax2.scatter(spatial_df['x'], spatial_df['y'], c=colors, s=sizes,\n                   edgecolors='black', linewidth=1, alpha=0.7)\n        \n        # Ajouter les marqueurs de significativit√©\n        for _, row in spatial_df.iterrows():\n            ax2.annotate(row['significance'], (row['x'], row['y']),\n                        ha='center', va='center', fontweight='bold',\n                        color='white' if row['significant'] else 'black')\n            \n            ax2.annotate(row['label'][:8], (row['x'], row['y']), \n                        xytext=(0, -25), textcoords='offset points',\n                        ha='center', fontsize=8)\n        \n        ax2.set_title('Significativit√© Statistique')\n        ax2.set_xlabel('Position X (Fraction)')\n        ax2.set_ylabel('Position Y')\n        ax2.grid(True, alpha=0.3)\n        \n        # L√©gende\n        from matplotlib.patches import Patch\n        legend_elements = [Patch(facecolor='red', label='Significatif (p < 0.05)'),\n                          Patch(facecolor='lightgray', label='Non significatif')]\n        ax2.legend(handles=legend_elements, loc='upper right')\n        \n        # 3. Graphique en barres des pentes\n        ax3 = axes[1, 0]\n        \n        # Trier par pente\n        sorted_data = spatial_df.sort_values('slope_decade')\n        \n        bars = ax3.barh(range(len(sorted_data)), sorted_data['slope_decade'],\n                       color=[FRACTION_COLORS.get(f, 'gray') for f in sorted_data['fraction']],\n                       alpha=0.7)\n        \n        # Ajouter une ligne √† z√©ro\n        ax3.axvline(x=0, color='black', linestyle='--', alpha=0.5)\n        \n        # Labels\n        ax3.set_yticks(range(len(sorted_data)))\n        ax3.set_yticklabels([label[:15] for label in sorted_data['label']])\n        ax3.set_xlabel('Pente de Sen (par d√©cennie)')\n        ax3.set_title('Pentes Tri√©es par Magnitude')\n        ax3.grid(True, alpha=0.3, axis='x')\n        \n        # Ajouter les valeurs de significativit√©\n        for i, (_, row) in enumerate(sorted_data.iterrows()):\n            significance = row['significance']\n            x_pos = row['slope_decade']\n            x_text = x_pos + (0.01 if x_pos >= 0 else -0.01)\n            ax3.text(x_text, i, significance, va='center', \n                    ha='left' if x_pos >= 0 else 'right', fontweight='bold')\n        \n        # 4. Heatmap de corr√©lation spatiale (simul√©e)\n        ax4 = axes[1, 1]\n        \n        # Cr√©er une matrice de \"distance\" entre fractions\n        n_fractions = len(spatial_df)\n        correlation_matrix = np.zeros((n_fractions, n_fractions))\n        \n        for i in range(n_fractions):\n            for j in range(n_fractions):\n                if i == j:\n                    correlation_matrix[i, j] = 1.0\n                else:\n                    # Corr√©lation simul√©e bas√©e sur la distance des pentes\n                    slope_i = spatial_df.iloc[i]['slope_decade']\n                    slope_j = spatial_df.iloc[j]['slope_decade']\n                    correlation_matrix[i, j] = np.exp(-abs(slope_i - slope_j) * 10)\n        \n        im = ax4.imshow(correlation_matrix, cmap='coolwarm', vmin=0, vmax=1)\n        \n        # Labels\n        labels = [label[:8] for label in spatial_df['label']]\n        ax4.set_xticks(range(n_fractions))\n        ax4.set_yticks(range(n_fractions))\n        ax4.set_xticklabels(labels, rotation=45, ha='right')\n        ax4.set_yticklabels(labels)\n        \n        # Ajouter les valeurs dans les cellules\n        for i in range(n_fractions):\n            for j in range(n_fractions):\n                ax4.text(j, i, f'{correlation_matrix[i, j]:.2f}',\n                        ha='center', va='center', fontweight='bold',\n                        color='white' if correlation_matrix[i, j] > 0.5 else 'black')\n        \n        ax4.set_title('Matrice de Similitude des Pentes')\n        plt.colorbar(im, ax=ax4, label='Similitude')\n        \n        plt.tight_layout()\n        \n        # Sauvegarder\n        if save_path is None:\n            save_path = f'spatial_slope_analysis_{variable}.png'\n        \n        plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        print(f\"‚úì Cartographie sauvegard√©e: {save_path}\")\n        \n        plt.show()\n        \n        # Stocker les r√©sultats\n        self.results[f'spatial_{variable}'] = {\n            'spatial_data': spatial_df,\n            'correlation_matrix': correlation_matrix,\n            'summary': {\n                'n_fractions': len(spatial_df),\n                'n_significant': spatial_df['significant'].sum(),\n                'slope_range': {\n                    'min': spatial_df['slope_decade'].min(),\n                    'max': spatial_df['slope_decade'].max(),\n                    'mean': spatial_df['slope_decade'].mean(),\n                    'std': spatial_df['slope_decade'].std()\n                }\n            }\n        }\n        \n        return save_path\n    \n    def create_spatial_distribution_analysis(self, trend_results, variable='mean', save_path=None):\n        \"\"\"\n        Analyse la distribution spatiale des tendances\n        \n        Args:\n            trend_results (dict): R√©sultats des analyses de tendances\n            variable (str): Variable analys√©e\n            save_path (str, optional): Chemin pour sauvegarder\n            \n        Returns:\n            str: Chemin du fichier sauvegard√©\n        \"\"\"\n        print_section_header(\"Analyse de distribution spatiale\", level=3)\n        \n        if not trend_results:\n            print(\"‚ùå Pas de donn√©es de tendances disponibles\")\n            return None\n        \n        # Pr√©parer les donn√©es\n        distribution_data = []\n        \n        for fraction, result in trend_results.items():\n            if result.get('error', False):\n                continue\n                \n            mk = result['mann_kendall']\n            sen = result['sen_slope']\n            \n            distribution_data.append({\n                'fraction': fraction,\n                'label': result['label'],\n                'slope_decade': sen['slope_per_decade'],\n                'p_value': mk['p_value'],\n                'trend': mk['trend'],\n                'n_obs': result['n_obs'],\n                'tau': mk['tau'],\n                'autocorr': result.get('autocorrelation', {}).get('lag1', np.nan)\n            })\n        \n        if not distribution_data:\n            print(\"‚ùå Pas de donn√©es pour l'analyse de distribution\")\n            return None\n        \n        distrib_df = pd.DataFrame(distribution_data)\n        \n        # Cr√©er la figure d'analyse\n        fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n        fig.suptitle(f'Analyse de Distribution Spatiale - {variable.title()}', \n                     fontsize=16, fontweight='bold')\n        \n        axes = axes.flatten()\n        \n        # 1. Distribution des pentes\n        ax1 = axes[0]\n        ax1.hist(distrib_df['slope_decade'], bins=8, alpha=0.7, color='skyblue', edgecolor='black')\n        ax1.axvline(x=0, color='red', linestyle='--', alpha=0.7, label='Pente nulle')\n        ax1.axvline(x=distrib_df['slope_decade'].mean(), color='green', linestyle='-', \n                   alpha=0.7, label='Moyenne')\n        ax1.set_title('Distribution des Pentes de Sen')\n        ax1.set_xlabel('Pente (par d√©cennie)')\n        ax1.set_ylabel('Fr√©quence')\n        ax1.legend()\n        ax1.grid(True, alpha=0.3)\n        \n        # 2. Distribution des p-values\n        ax2 = axes[1]\n        ax2.hist(distrib_df['p_value'], bins=8, alpha=0.7, color='lightcoral', edgecolor='black')\n        ax2.axvline(x=0.05, color='red', linestyle='--', alpha=0.7, label='Seuil Œ±=0.05')\n        ax2.set_title('Distribution des P-values')\n        ax2.set_xlabel('P-value')\n        ax2.set_ylabel('Fr√©quence')\n        ax2.legend()\n        ax2.grid(True, alpha=0.3)\n        \n        # 3. Relation pente vs p-value\n        ax3 = axes[2]\n        colors = ['red' if p < 0.05 else 'gray' for p in distrib_df['p_value']]\n        ax3.scatter(distrib_df['slope_decade'], -np.log10(distrib_df['p_value']), \n                   c=colors, alpha=0.7, s=100, edgecolors='black')\n        ax3.axhline(y=-np.log10(0.05), color='red', linestyle='--', alpha=0.7, \n                   label='Seuil significativit√©')\n        ax3.axvline(x=0, color='black', linestyle='-', alpha=0.3)\n        ax3.set_title('Volcano Plot: Pente vs Significativit√©')\n        ax3.set_xlabel('Pente de Sen (par d√©cennie)')\n        ax3.set_ylabel('-log10(p-value)')\n        ax3.legend()\n        ax3.grid(True, alpha=0.3)\n        \n        # 4. Nombre d'observations par fraction\n        ax4 = axes[3]\n        bars = ax4.bar(range(len(distrib_df)), distrib_df['n_obs'],\n                      color=[FRACTION_COLORS.get(f, 'gray') for f in distrib_df['fraction']],\n                      alpha=0.7, edgecolor='black')\n        ax4.set_title('Nombre d\\'Observations par Fraction')\n        ax4.set_xlabel('Fraction')\n        ax4.set_ylabel('Nombre d\\'Observations')\n        ax4.set_xticks(range(len(distrib_df)))\n        ax4.set_xticklabels([label[:8] for label in distrib_df['label']], rotation=45)\n        ax4.grid(True, alpha=0.3, axis='y')\n        \n        # Ajouter les valeurs sur les barres\n        for bar, n_obs in zip(bars, distrib_df['n_obs']):\n            ax4.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 5,\n                    str(n_obs), ha='center', va='bottom', fontweight='bold')\n        \n        # 5. Boxplot des tendances par type\n        ax5 = axes[4]\n        \n        # Grouper par type de tendance\n        trend_groups = distrib_df.groupby('trend')['slope_decade'].apply(list).to_dict()\n        \n        if trend_groups:\n            trends = list(trend_groups.keys())\n            slopes = [trend_groups[trend] for trend in trends]\n            \n            bp = ax5.boxplot(slopes, labels=trends, patch_artist=True)\n            \n            # Couleurs selon le type de tendance\n            colors = ['lightgreen' if t == 'increasing' else 'lightcoral' if t == 'decreasing' else 'lightgray' \n                     for t in trends]\n            for patch, color in zip(bp['boxes'], colors):\n                patch.set_facecolor(color)\n                patch.set_alpha(0.7)\n        \n        ax5.axhline(y=0, color='black', linestyle='--', alpha=0.5)\n        ax5.set_title('Distribution des Pentes par Type de Tendance')\n        ax5.set_ylabel('Pente de Sen (par d√©cennie)')\n        ax5.grid(True, alpha=0.3)\n        \n        # 6. Statistiques r√©sum√©es\n        ax6 = axes[5]\n        ax6.axis('off')\n        \n        # Calculs de statistiques\n        n_total = len(distrib_df)\n        n_significant = (distrib_df['p_value'] < 0.05).sum()\n        n_increasing = (distrib_df['trend'] == 'increasing').sum()\n        n_decreasing = (distrib_df['trend'] == 'decreasing').sum()\n        n_no_trend = (distrib_df['trend'] == 'no trend').sum()\n        \n        mean_slope = distrib_df['slope_decade'].mean()\n        std_slope = distrib_df['slope_decade'].std()\n        median_slope = distrib_df['slope_decade'].median()\n        \n        stats_text = f\"\"\"\nSTATISTIQUES SPATIALES\n\n‚Ä¢ Total fractions analys√©es: {n_total}\n‚Ä¢ Tendances significatives: {n_significant} ({n_significant/n_total*100:.1f}%)\n\n‚Ä¢ Type de tendances:\n  - Croissantes: {n_increasing}\n  - D√©croissantes: {n_decreasing} \n  - Pas de tendance: {n_no_trend}\n\n‚Ä¢ Pentes de Sen:\n  - Moyenne: {mean_slope:.6f}/d√©cennie\n  - M√©diane: {median_slope:.6f}/d√©cennie\n  - √âcart-type: {std_slope:.6f}/d√©cennie\n  - Min: {distrib_df['slope_decade'].min():.6f}/d√©cennie\n  - Max: {distrib_df['slope_decade'].max():.6f}/d√©cennie\n        \"\"\"\n        \n        ax6.text(0.05, 0.95, stats_text, transform=ax6.transAxes, fontsize=11,\n                verticalalignment='top', fontfamily='monospace',\n                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))\n        \n        plt.tight_layout()\n        \n        # Sauvegarder\n        if save_path is None:\n            save_path = f'spatial_distribution_analysis_{variable}.png'\n        \n        plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        print(f\"‚úì Analyse de distribution sauvegard√©e: {save_path}\")\n        \n        plt.show()\n        \n        return save_path\n    \n    def get_spatial_summary_table(self, variable='mean'):\n        \"\"\"\n        G√©n√®re un tableau de r√©sum√© de l'analyse spatiale\n        \n        Args:\n            variable (str): Variable analys√©e\n            \n        Returns:\n            pd.DataFrame: Tableau de r√©sum√© spatial\n        \"\"\"\n        if f'spatial_{variable}' not in self.results:\n            raise ValueError(f\"Analyse spatiale non effectu√©e pour {variable}\")\n        \n        spatial_data = self.results[f'spatial_{variable}']['spatial_data']\n        \n        summary_table = spatial_data[[\n            'label', 'slope_decade', 'p_value', 'trend', \n            'significance', 'n_obs', 'significant'\n        ]].copy()\n        \n        summary_table.columns = [\n            'Fraction', 'Pente_Sen_decade', 'P_value', 'Tendance',\n            'Significativit√©', 'N_observations', 'Significatif'\n        ]\n        \n        return summary_table.sort_values('Pente_Sen_decade', ascending=False)\n    \n    def print_spatial_summary(self, variable='mean'):\n        \"\"\"\n        Affiche un r√©sum√© de l'analyse spatiale\n        \"\"\"\n        print_section_header(\"R√©sum√© de l'analyse spatiale\", level=2)\n        \n        if f'spatial_{variable}' not in self.results:\n            print(\"‚ùå Analyse spatiale non effectu√©e\")\n            return\n        \n        summary = self.results[f'spatial_{variable}']['summary']\n        spatial_data = self.results[f'spatial_{variable}']['spatial_data']\n        \n        print(f\"üó∫Ô∏è  Fractions analys√©es: {summary['n_fractions']}\")\n        print(f\"‚úÖ Tendances significatives: {summary['n_significant']}\")\n        \n        slope_range = summary['slope_range']\n        print(f\"\\nüìê Pentes de Sen (par d√©cennie):\")\n        print(f\"  ‚Ä¢ Minimum: {slope_range['min']:.6f}\")\n        print(f\"  ‚Ä¢ Maximum: {slope_range['max']:.6f}\")\n        print(f\"  ‚Ä¢ Moyenne: {slope_range['mean']:.6f}\")\n        print(f\"  ‚Ä¢ √âcart-type: {slope_range['std']:.6f}\")\n        \n        # Fractions les plus extr√™mes\n        max_increase = spatial_data.loc[spatial_data['slope_decade'].idxmax()]\n        max_decrease = spatial_data.loc[spatial_data['slope_decade'].idxmin()]\n        \n        print(f\"\\nüéØ Fractions extr√™mes:\")\n        print(f\"  üìà Plus forte augmentation: {max_increase['label']} \")\n        print(f\"     Pente: {max_increase['slope_decade']:.6f}/d√©cennie {max_increase['significance']}\")\n        print(f\"  üìâ Plus forte diminution: {max_decrease['label']} \")\n        print(f\"     Pente: {max_decrease['slope_decade']:.6f}/d√©cennie {max_decrease['significance']}\")\n        \n        # Significativit√© spatiale\n        significant_fractions = spatial_data[spatial_data['significant']]\n        if len(significant_fractions) > 0:\n            print(f\"\\nüåü Fractions avec tendances significatives:\")\n            for _, row in significant_fractions.iterrows():\n                trend_symbol = TREND_SYMBOLS.get(row['trend'], '‚ùì')\n                print(f\"  {trend_symbol} {row['label']}: {row['slope_decade']:.6f}/d√©cennie {row['significance']}\")\n        else:\n            print(f\"\\n‚ùå Aucune fraction avec tendance significative\")"